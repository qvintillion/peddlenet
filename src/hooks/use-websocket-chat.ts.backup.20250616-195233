'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { io, Socket } from 'socket.io-client';
import type { Message, ConnectionStatus } from '@/lib/types';
import { generateCompatibleUUID } from '@/utils/peer-utils';
import { NetworkUtils } from '@/utils/network-utils';
import { MessagePersistence } from '@/utils/message-persistence';
import { ServerUtils } from '@/utils/server-utils';
import { unreadMessageManager } from '@/hooks/use-unread-messages';

// Enhanced connection resilience with Cloud Run optimizations
const createEnhancedConnectionResilience = () => {
  let circuitBreaker = {
    isOpen: false,
    failureCount: 0,
    lastFailureTime: 0,
    successCount: 0,
    lastSuccessTime: 0
  };
  
  let backoffState = {
    currentAttempt: 0,
    lastAttemptTime: 0
  };
  
  const FAILURE_THRESHOLD = 3;
  const RECOVERY_TIMEOUT = 8000;
  const SUCCESS_THRESHOLD = 2;
  const MAX_BACKOFF = 12000;
  const COLD_START_BACKOFF = 2000;
  
  return {
    shouldAllowConnection(): boolean {
      const now = Date.now();
      const timeSinceLastFailure = now - circuitBreaker.lastFailureTime;
      
      if (circuitBreaker.isOpen) {
        if (timeSinceLastFailure > RECOVERY_TIMEOUT) {
          console.log('üîÑ Circuit breaker attempting recovery - allowing test connection');
          return true;
        }
        console.log('üö´ Circuit breaker open - blocking connection');
        return false;
      }
      
      return true;
    },
    
    recordSuccess(): void {
      const now = Date.now();
      circuitBreaker.successCount++;
      circuitBreaker.lastSuccessTime = now;
      backoffState.currentAttempt = 0;
      
      if (circuitBreaker.isOpen && circuitBreaker.successCount >= SUCCESS_THRESHOLD) {
        circuitBreaker.isOpen = false;
        circuitBreaker.failureCount = 0;
        circuitBreaker.successCount = 0;
        console.log('‚úÖ Circuit breaker closed - connection stable');
      }
    },
    
    recordFailure(): void {
      const now = Date.now();
      circuitBreaker.failureCount++;
      circuitBreaker.lastFailureTime = now;
      circuitBreaker.successCount = 0;
      
      if (circuitBreaker.failureCount >= FAILURE_THRESHOLD) {
        circuitBreaker.isOpen = true;
        console.log(`‚ö° Circuit breaker opened after ${circuitBreaker.failureCount} failures`);
      }
    },
    
    getExponentialBackoffDelay(attempt?: number, isColdStart?: boolean): number {
      if (isColdStart) {
        const jitter = Math.random() * 500;
        const delay = COLD_START_BACKOFF + jitter;
        console.log(`‚ùÑÔ∏è Cold start backoff: ${Math.round(delay)}ms`);
        return delay;
      }
      
      const currentAttempt = attempt !== undefined ? attempt : backoffState.currentAttempt;
      const baseDelay = 1000;
      const jitter = Math.random() * 500;
      
      const delay = Math.min(baseDelay * Math.pow(1.5, currentAttempt) + jitter, MAX_BACKOFF);
      backoffState.currentAttempt = currentAttempt + 1;
      backoffState.lastAttemptTime = Date.now();
      
      console.log(`‚è±Ô∏è Enhanced backoff: attempt ${currentAttempt}, delay ${Math.round(delay)}ms`);
      return delay;
    },
    
    getAdaptiveTimeout(): number {
      const recentFailures = circuitBreaker.failureCount;
      const baseTimeout = 15000; // Increased for Cloud Run cold starts
      
      if (recentFailures > 1) {
        return Math.min(baseTimeout * 1.8, 30000); // Up to 30s for cold starts
      }
      
      return baseTimeout;
    },
    
    reset(): void {
      circuitBreaker = {
        isOpen: false,
        failureCount: 0,
        lastFailureTime: 0,
        successCount: 0,
        lastSuccessTime: 0
      };
      backoffState = {
        currentAttempt: 0,
        lastAttemptTime: 0
      };
      console.log('üîÑ Circuit breaker reset for Cloud Run compatibility');
    },
    
    getState() {
      return {
        circuitBreaker: { ...circuitBreaker },
        backoffState: { ...backoffState }
      };
    }
  };
};

const EnhancedConnectionResilience = createEnhancedConnectionResilience();

// FIXED: Enhanced WebSocket URL detection with correct production server
const getWebSocketServerUrl = () => {
  if (typeof window === 'undefined') return 'ws://localhost:3001';
  
  const hostname = window.location.hostname;
  const port = window.location.port;
  
  console.log(`üîç WebSocket URL Detection:`, {
    hostname,
    port,
    protocol: window.location.protocol,
    detectedIP: process.env.NEXT_PUBLIC_DETECTED_IP,
    userAgent: navigator.userAgent.includes('Mobile') ? 'mobile' : 'desktop'
  });
  
  // Local development detection
  const isLocalDev = hostname === 'localhost' || hostname === '127.0.0.1';
  const isPrivateIP = hostname.match(/^192\.168\.|^10\.|^172\.(1[6-9]|2[0-9]|3[01])\./); 
  
  // CRITICAL FIX: Handle local development properly
  if (isLocalDev) {
    const url = `ws://localhost:3001`;
    console.log(`üè† Local development WebSocket: ${url}`);
    return url;
  }
  
  // CRITICAL FIX: Handle mobile accessing dev server via IP
  if (isPrivateIP || port === '3000') {
    const url = `ws://${hostname}:3001`;
    console.log(`üì± Mobile development WebSocket: ${url}`);
    return url;
  }
  
  // CRITICAL FIX: Use environment variable or correct production server URL
  const productionWebSocketUrl = process.env.NEXT_PUBLIC_SIGNALING_SERVER || 'wss://peddlenet-websocket-server-hfttiarlja-uc.a.run.app';
  
  // Firebase hosting - use production WebSocket server
  if (hostname.includes('firebase') || hostname.includes('web.app')) {
    console.log(`üî• Firebase WebSocket: ${productionWebSocketUrl}`);
    return productionWebSocketUrl;
  }
  
  // Vercel production - use production WebSocket server
  if (hostname.includes('vercel.app') || hostname === 'peddlenet.app') {
    console.log(`‚ñ≤ Vercel WebSocket: ${productionWebSocketUrl}`);
    return productionWebSocketUrl;
  }
  
  // Default fallback with warning
  const fallbackUrl = 'ws://localhost:3001'; // Changed to local for development
  console.warn(`‚ö†Ô∏è Using fallback WebSocket URL: ${fallbackUrl}`);
  return fallbackUrl;
};

// Health monitoring with Cloud Run awareness
const createHealthMonitor = () => {
  let healthState = {
    lastPing: 0,
    lastPong: 0,
    pingCount: 0,
    pongCount: 0,
    averageLatency: 0,
    connectionQuality: 'unknown' as 'excellent' | 'good' | 'poor' | 'unknown',
    coldStartDetected: false
  };
  
  return {
    recordPing(): void {
      healthState.lastPing = Date.now();
      healthState.pingCount++;
    },
    
    recordPong(): void {
      const now = Date.now();
      const latency = now - healthState.lastPing;
      
      healthState.lastPong = now;
      healthState.pongCount++;
      
      healthState.averageLatency = healthState.averageLatency === 0 
        ? latency 
        : (healthState.averageLatency * 0.7) + (latency * 0.3);
      
      // Cloud Run aware quality assessment
      if (latency < 200) {
        healthState.connectionQuality = 'excellent';
        healthState.coldStartDetected = false;
      } else if (latency < 500) {
        healthState.connectionQuality = 'good';
        healthState.coldStartDetected = false;
      } else if (latency < 2000) {
        healthState.connectionQuality = 'poor';
        healthState.coldStartDetected = latency > 1000;
      } else {
        healthState.connectionQuality = 'poor';
        healthState.coldStartDetected = true;
      }
      
      if (healthState.coldStartDetected) {
        console.log(`‚ùÑÔ∏è Cold start detected: ${latency}ms latency`);
      }
    },
    
    isHealthy(): boolean {
      const now = Date.now();
      const timeSinceLastPong = now - healthState.lastPong;
      return timeSinceLastPong < 60000 && healthState.connectionQuality !== 'poor';
    },
    
    getHealthMetrics() {
      return {
        ...healthState,
        timeSinceLastPong: Date.now() - healthState.lastPong,
        isHealthy: this.isHealthy()
      };
    }
  };
};

export function useWebSocketChat(roomId: string, displayName?: string) {
  const [isConnected, setIsConnected] = useState(false);
  const [messages, setMessages] = useState<Message[]>([]);
  const [connectedPeers, setConnectedPeers] = useState<string[]>([]);
  const [isRetrying, setIsRetrying] = useState(false);
  const [retryCount, setRetryCount] = useState(0);
  const [connectionCooldown, setConnectionCooldown] = useState(false);
  const [shouldAutoReconnect, setShouldAutoReconnect] = useState(true);
  const [connectionQuality, setConnectionQuality] = useState<'excellent' | 'good' | 'poor' | 'unknown'>('unknown');
  
  const socketRef = useRef<Socket | null>(null);
  const messageHandlersRef = useRef<Set<(message: Message) => void>>(new Set());
  const healthMonitor = useRef(createHealthMonitor());
  const autoReconnectTimer = useRef<NodeJS.Timeout | null>(null);
  const healthCheckTimer = useRef<NodeJS.Timeout | null>(null);
  
  // CRITICAL FIX: Add global connection lock to prevent loops
  const connectionLockRef = useRef<boolean>(false);
  const lastConnectionAttempt = useRef<number>(0);
  const MIN_CONNECTION_INTERVAL = 5000; // Minimum 5 seconds between attempts
  
  const effectiveDisplayName = displayName && displayName.trim() && displayName !== 'Anonymous' ? displayName.trim() : null;
  const myPeerId = useRef<string>(generateCompatibleUUID());
  const connectionId = useRef<string>(Math.random().toString(36).substring(7));
  const roomConnectionRef = useRef<string>('');
  const isConnectingRef = useRef(false);
  const lastSuccessfulConnection = useRef<number>(0);

  const status: ConnectionStatus = {
    isConnected,
    connectedPeers: connectedPeers.length,
    networkReach: isConnected ? 'server' as const : 'isolated' as const,
    signalStrength: connectionQuality === 'excellent' ? 'strong' as const : 
                   connectionQuality === 'good' ? 'medium' as const : 
                   connectionQuality === 'poor' ? 'weak' as const : 'none' as const,
  };

  const startHealthMonitoring = useCallback((socket: Socket) => {
    if (healthCheckTimer.current) {
      clearInterval(healthCheckTimer.current);
    }
    
    healthCheckTimer.current = setInterval(() => {
      if (socket && socket.connected) {
        healthMonitor.current.recordPing();
        socket.emit('health-ping', { timestamp: Date.now() });
      }
    }, 20000); // Every 20 seconds for Cloud Run
    
    console.log('üè• Health monitoring started (Cloud Run optimized)');
  }, []);

  const stopHealthMonitoring = useCallback(() => {
    if (healthCheckTimer.current) {
      clearInterval(healthCheckTimer.current);
      healthCheckTimer.current = null;
      console.log('üè• Health monitoring stopped');
    }
  }, []);

  // Enhanced Cloud Run compatible connection
  const connectToServer = useCallback(async () => {
    const now = Date.now();
    
    // CRITICAL FIX: Multiple connection guards
    if (connectionLockRef.current) {
      console.log(`üîí Connection lock active, skipping attempt`);
      return;
    }
    
    if (now - lastConnectionAttempt.current < MIN_CONNECTION_INTERVAL) {
      console.log(`‚è∞ Too soon since last attempt (${now - lastConnectionAttempt.current}ms < ${MIN_CONNECTION_INTERVAL}ms)`);
      return;
    }
    
    if (socketRef.current?.connected) {
      console.log(`üîÑ Already connected, skipping duplicate connection attempt`);
      return;
    }
    
    if (!EnhancedConnectionResilience.shouldAllowConnection()) {
      console.log(`üö´ [${connectionId.current}] Circuit breaker blocking connection`);
      return;
    }
    
    if (!roomId || !effectiveDisplayName || isConnectingRef.current) {
      console.log(`‚è∏Ô∏è [${connectionId.current}] Skipping connection - missing requirements or already connecting`);
      return;
    }
    
    // CRITICAL FIX: Set connection lock
    connectionLockRef.current = true;
    lastConnectionAttempt.current = now;
    console.log(`üîí Connection lock acquired, attempting connection...`);
    
    const timeSinceLastSuccess = now - lastSuccessfulConnection.current;
    if (timeSinceLastSuccess < 3000 && socketRef.current?.connected) {
      console.log(`‚è≥ [${connectionId.current}] Too soon since last connection`);
      connectionLockRef.current = false; // Release lock
      return;
    }
    
    if (connectionCooldown && roomConnectionRef.current === roomId) {
      console.log(`‚è≥ [${connectionId.current}] In cooldown`);
      return;
    }
    
    // Handle room switching
    if (socketRef.current?.connected && roomConnectionRef.current !== roomId) {
      console.log(`üîÑ [${connectionId.current}] Room switching:`, roomConnectionRef.current, '‚Üí', roomId);
      stopHealthMonitoring();
      socketRef.current.disconnect();
      socketRef.current = null;
      roomConnectionRef.current = '';
    }
    
    isConnectingRef.current = true;
    
    if (socketRef.current) {
      console.log('Disconnecting existing socket before new connection');
      stopHealthMonitoring();
      socketRef.current.disconnect();
      socketRef.current = null;
    }

    const serverUrl = getWebSocketServerUrl(); // Use updated function
    const envInfo = ServerUtils.getEnvironmentInfo();
    
    console.log('üîç Enhanced Cloud Run connection details:');
    console.log('  - WebSocket URL:', serverUrl);
    console.log('  - Environment:', envInfo.environment);
    console.log('  - Adaptive timeout:', EnhancedConnectionResilience.getAdaptiveTimeout());
    
    if (!serverUrl) {
      console.error('‚ùå No WebSocket server URL configured');
      isConnectingRef.current = false;
      return;
    }

    setIsRetrying(true);
    console.log(`üîå [${connectionId.current}] Enhanced Cloud Run connection to:`, serverUrl, 'as:', effectiveDisplayName);

    const adaptiveTimeout = EnhancedConnectionResilience.getAdaptiveTimeout();
    
    // FIXED: More conservative Socket.IO configuration to prevent conflicts
    const socket = io(serverUrl, {
      // CRITICAL FIX: Use websocket-only for local development to avoid polling conflicts
      transports: ['websocket'],
      
      timeout: 5000, // Shorter timeout to fail fast
      forceNew: true,
      autoConnect: false, // CRITICAL: Manual connection control
      
      // FIXED: Disable reconnection completely (let our logic handle it)
      reconnection: false,
      reconnectionAttempts: 0,
      
      // FIXED: Conservative timeouts to avoid hanging
      pingTimeout: 15000, // Reduced from 30s
      pingInterval: 10000, // Reduced from 15s
      
      // FIXED: Minimal options to avoid conflicts
      upgrade: false, // Disable transport upgrades
      rememberUpgrade: false,
      withCredentials: false,
      closeOnBeforeunload: true,
      
      // FIXED: No extra headers for local development
      extraHeaders: {}
    });
    
    // CRITICAL FIX: Manual connection with better error handling
    try {
      console.log(`üîå Attempting manual connection to: ${serverUrl}`);
      socket.connect();
      
      // Set a connection timeout
      const connectionTimeout = setTimeout(() => {
        if (!socket.connected) {
          console.error(`‚è∞ Connection timeout after 5 seconds`);
          socket.disconnect();
          isConnectingRef.current = false;
          setIsRetrying(false);
          
          // Try again after a delay
          setTimeout(() => {
            if (shouldAutoReconnect && effectiveDisplayName) {
              console.log(`üîÑ Retrying after timeout...`);
              connectToServer();
            }
          }, 5000);
        }
      }, 5000);
      
      // Clear timeout on successful connection
      socket.on('connect', () => {
        clearTimeout(connectionTimeout);
      });
      
    } catch (connectError) {
      console.error('‚ùå Socket connection failed:', connectError);
      isConnectingRef.current = false;
      setIsRetrying(false);
      return;
    }

    socketRef.current = socket;

    // Enhanced connection event handlers with Cloud Run awareness
    socket.on('connect', () => {
      const now = Date.now();
      console.log(`üöÄ [${connectionId.current}] Cloud Run connection established as:`, effectiveDisplayName);
      console.log(`   Transport: ${socket.io.engine.transport.name}, Upgraded: ${socket.io.engine.upgraded}`);
      
      // CRITICAL FIX: Release connection lock on successful connection
      connectionLockRef.current = false;
      
      setIsConnected(true);
      setIsRetrying(false);
      setRetryCount(0);
      isConnectingRef.current = false;
      roomConnectionRef.current = roomId;
      lastSuccessfulConnection.current = now;
      
      // Record successful connection
      EnhancedConnectionResilience.recordSuccess();
      
      // Start enhanced health monitoring
      startHealthMonitoring(socket);
      
      socket.emit('join-room', {
        roomId,
        peerId: myPeerId.current,
        displayName: effectiveDisplayName
      });
      
      // Enhanced message history handling with longer timeout for cold starts
      setTimeout(() => {
        const localMessages = MessagePersistence.getRoomMessages(roomId);
        if (localMessages.length > 0) {
          console.log('‚è∞ Cloud Run history timeout, using local fallback:', localMessages.length);
          setMessages(prev => prev.length === 0 ? localMessages : prev);
        }
      }, 5000); // Increased timeout for Cloud Run cold starts
    });

    // Enhanced disconnect handling with Cloud Run cold start detection
    socket.on('disconnect', (reason) => {
      console.log(`üîå [${connectionId.current}] Enhanced disconnect:`, reason);
      console.log(`   Transport: ${socket.io.engine?.transport?.name || 'unknown'}`);
      
      // CRITICAL FIX: Always release connection lock on disconnect
      connectionLockRef.current = false;
      
      setIsConnected(false);
      isConnectingRef.current = false;
      roomConnectionRef.current = '';
      stopHealthMonitoring();
      
      // Enhanced Cloud Run disconnect reason analysis
      const isCloudRunColdStart = reason === 'transport close' || 
                                  reason === 'ping timeout' ||
                                  reason === 'transport error';
      
      const isUnexpected = reason !== 'client namespace disconnect' && 
                          reason !== 'io client disconnect';
      
      if (isCloudRunColdStart) {
        console.log(`‚ùÑÔ∏è [${connectionId.current}] Cloud Run cold start detected - will retry after delay`);
      } else if (isUnexpected) {
        console.log(`‚ö†Ô∏è [${connectionId.current}] Unexpected disconnect:`, reason);
        EnhancedConnectionResilience.recordFailure();
      }
      
      // CRITICAL FIX: Much longer delays and limited retries
      if (shouldAutoReconnect && effectiveDisplayName && !reason.includes('server') && retryCount < 3) {
        const backoffDelay = Math.max(10000, 5000 * Math.pow(2, retryCount)); // Minimum 10s, then 10s, 20s, 40s
          
        console.log(`üîÑ [${connectionId.current}] Auto-reconnect in ${backoffDelay}ms (attempt ${retryCount + 1}/3)`);
        
        autoReconnectTimer.current = setTimeout(() => {
          console.log(`üîÑ [${connectionId.current}] Attempting auto-reconnect...`);
          connectToServer();
        }, backoffDelay);
      } else {
        console.log(`üõë [${connectionId.current}] Auto-reconnect disabled or max retries reached`);
      }
    });

    // FIXED: Simplified error handling to prevent loops
    socket.on('connect_error', (error) => {
      const errorMessage = error?.message || 'Unknown connection error';
      const errorType = error?.type || 'unknown';
      
      console.error('‚ùå WebSocket connection error:', errorMessage, 'Type:', errorType, 'URL:', serverUrl, 'Attempt:', retryCount + 1);
      
      // CRITICAL FIX: Always release connection lock on error
      connectionLockRef.current = false;
      
      setIsConnected(false);
      setIsRetrying(false);
      isConnectingRef.current = false;
      
      // CRITICAL FIX: Prevent infinite retry loops
      const isFatalError = errorMessage.includes('CORS') || 
                          errorMessage.includes('403') || 
                          errorMessage.includes('404') ||
                          errorMessage.includes('rate limit');
      
      if (isFatalError) {
        console.error(`üö® Fatal error detected, stopping retries: ${errorMessage}`);
        setShouldAutoReconnect(false);
        EnhancedConnectionResilience.recordFailure();
        return;
      }
      
      // Record failure for circuit breaker
      EnhancedConnectionResilience.recordFailure();
      
      // CRITICAL FIX: Much more conservative retry with longer delays
      const backoffDelay = Math.max(15000, 10000 * Math.pow(2, retryCount)); // Minimum 15s, then 15s, 30s, 60s
      
      setRetryCount(prev => prev + 1);
      setConnectionCooldown(true);
      
      // CRITICAL FIX: Stop retrying after 2 attempts
      if (retryCount >= 2) {
        console.error(`üõë Max retry attempts reached (${retryCount}), stopping completely`);
        setShouldAutoReconnect(false);
        setConnectionCooldown(false);
        return;
      }
      
      console.log(`üîÑ Retrying connection in ${backoffDelay}ms (attempt ${retryCount + 1}/2)`);
      
      setTimeout(() => {
        setConnectionCooldown(false);
        if (shouldAutoReconnect && effectiveDisplayName) {
          connectToServer();
        }
      }, backoffDelay);
    });

    // Enhanced health monitoring handlers
    socket.on('health-pong', (data) => {
      healthMonitor.current.recordPong();
      const metrics = healthMonitor.current.getHealthMetrics();
      setConnectionQuality(metrics.connectionQuality);
      
      if (!metrics.isHealthy && isConnected) {
        console.log('üè• Connection health degraded, monitoring...');
      }
    });

    // Enhanced server shutdown handling
    socket.on('server-shutdown', (data) => {
      console.log('üõë Server shutdown notification:', data);
      setShouldAutoReconnect(false);
      
      setTimeout(() => {
        setShouldAutoReconnect(true);
        console.log('üîÑ Attempting reconnection after server maintenance...');
        connectToServer();
      }, data.reconnectDelay || 15000); // Longer delay for Cloud Run
    });

    // CRITICAL: Handle database wipe events
    socket.on('database-wiped', (data) => {
      console.log('üóëÔ∏è Database wiped notification received:', data);
      
      // Clear all local message state immediately
      setMessages([]);
      
      // Clear persisted messages for this room
      try {
        MessagePersistence.clearRoomMessages(roomId);
        console.log('üßπ Cleared local message persistence for room:', roomId);
      } catch (error) {
        console.warn('Failed to clear local persistence:', error);
      }
      
      // Clear all unread message counts
      try {
        unreadMessageManager.clearAll();
        console.log('üßπ Cleared all unread message counts');
      } catch (error) {
        console.warn('Failed to clear unread counts:', error);
      }
      
      // Force reload if requested
      if (data.forceReload && typeof window !== 'undefined') {
        console.log('üîÑ Force reloading page after database wipe...');
        setTimeout(() => {
          window.location.reload();
        }, 1000);
      }
    });

    // Handle force refresh events
    socket.on('force-refresh', (data) => {
      console.log('üîÑ Force refresh notification:', data);
      
      // Clear all local state
      setMessages([]);
      setConnectedPeers([]);
      
      // Clear local persistence
      try {
        MessagePersistence.clearRoomMessages(roomId);
      } catch (error) {
        console.warn('Failed to clear local persistence:', error);
      }
      
      // Clear all unread message counts
      try {
        unreadMessageManager.clearAll();
        console.log('üßπ Cleared all unread message counts');
      } catch (error) {
        console.warn('Failed to clear unread counts:', error);
      }
      
      // Optionally reload page
      if (data.forceReload !== false && typeof window !== 'undefined') {
        setTimeout(() => {
          window.location.reload();
        }, 500);
      }
    });

    // CRITICAL: Handle room-specific message clearing
    socket.on('room-messages-cleared', (data) => {
      console.log('üóëÔ∏è Room messages cleared notification received:', data);
      
      // Only clear if this is for the current room
      if (data.roomId === roomId) {
        console.log(`üßπ Clearing local state for room: ${data.roomId}`);
        
        // Clear messages from React state
        setMessages([]);
        
        // Clear persisted messages for this specific room
        try {
          MessagePersistence.clearRoomMessages(data.roomId);
          console.log(`üßπ Cleared local message persistence for room: ${data.roomId}`);
        } catch (error) {
          console.warn('Failed to clear local persistence for room:', error);
        }
        
        // Clear unread message counts for this specific room
        try {
          unreadMessageManager.clearRoom(data.roomId);
          console.log(`üßπ Cleared unread message counts for room: ${data.roomId}`);
        } catch (error) {
          console.warn('Failed to clear unread counts for room:', error);
        }
        
        // Show a brief notification to the user
        if (typeof window !== 'undefined' && data.message) {
          // You could show a toast notification here if available
          console.log(`üì¢ Admin message: ${data.message}`);
        }
      } else {
        console.log(`‚ÑπÔ∏è Room messages cleared for different room (${data.roomId}), ignoring`);
      }
    });

    // Standard message handling (unchanged)
    socket.on('message-history', (messageHistory: Message[]) => {
      console.log('üìö Enhanced message history received:', messageHistory.length);
      
      const localMessages = MessagePersistence.getRoomMessages(roomId);
      
      if (messageHistory.length > 0) {
        const mergedMessages = MessagePersistence.mergeMessages(roomId, messageHistory, localMessages);
        setMessages(mergedMessages);
        MessagePersistence.saveRoomMessages(roomId, mergedMessages, connectedPeers.length);
      } else {
        console.log('üìÇ Enhanced: No server history, using local messages:', localMessages.length);
        if (localMessages.length > 0) {
          setMessages(localMessages);
        }
      }
    });

    socket.on('chat-message', (message: any) => {
      console.log('üì• Enhanced real-time message:', message);
      
      const normalizedMessage: Message = {
        id: message.id || generateCompatibleUUID(),
        content: message.content || '',
        sender: message.sender || 'Unknown',
        timestamp: message.timestamp || Date.now(),
        type: message.type || 'chat',
        roomId: roomId,
        synced: true
      };
      
      setMessages(prev => {
        const isDuplicate = prev.some(m => m.id === normalizedMessage.id);
        if (isDuplicate) {
          console.log('‚ö†Ô∏è Enhanced: Duplicate message ignored:', normalizedMessage.id);
          return prev;
        }
        
        const updated = [...prev, normalizedMessage].sort((a, b) => a.timestamp - b.timestamp);
        MessagePersistence.addMessage(roomId, normalizedMessage);
        
        return updated;
      });
      
      messageHandlersRef.current.forEach(handler => {
        try {
          handler(normalizedMessage);
        } catch (e) {
          console.error('Enhanced message handler error:', e);
        }
      });
    });

    // Enhanced peer management with strict deduplication
    socket.on('room-peers', (peers: any[]) => {
      console.log('Enhanced room peers total:', peers.length);
      
      // First, filter out invalid peer data
      const validPeers = peers.filter(p => 
        p && 
        p.displayName && 
        typeof p.displayName === 'string' && 
        p.displayName.trim() && 
        p.displayName !== effectiveDisplayName
      );
      
      // Then, get unique display names (case-sensitive but trimmed)
      const uniquePeerNames = Array.from(
        new Set(validPeers.map(p => p.displayName.trim()))
      ).filter(name => name && name !== effectiveDisplayName);
      
      const namedUsers = uniquePeerNames.filter(name => !name.startsWith('User_'));
      const anonymousUsers = uniquePeerNames.filter(name => name.startsWith('User_'));
      
      console.log('Enhanced unique peers:', {
        total: uniquePeerNames.length,
        named: namedUsers.length,
        anonymous: anonymousUsers.length,
        namedUsers,
        anonymousUsers
      });
      
      setConnectedPeers(uniquePeerNames);
    });

    socket.on('peer-joined', (peer: any) => {
      if (!peer || !peer.displayName || !peer.displayName.trim()) {
        console.warn('Invalid peer data received:', peer);
        return;
      }
      
      const trimmedName = peer.displayName.trim();
      
      // Skip if it's ourselves
      if (trimmedName === effectiveDisplayName) {
        return;
      }
      
      const isAnonymous = trimmedName.startsWith('User_');
      const logMessage = isAnonymous 
        ? `üìù Anonymous user joined: ${trimmedName}`
        : `üëã User joined: ${trimmedName}`;
      
      console.log(logMessage, peer.isReconnection ? '(reconnection)' : '(new)');
      
      setConnectedPeers(prev => {
        // Ensure no duplicates by checking trimmed names
        if (prev.some(name => name.trim() === trimmedName)) {
          return prev;
        }
        return [...prev, trimmedName];
      });
    });

    socket.on('peer-left', (peer: any) => {
      if (!peer || !peer.displayName) {
        console.warn('Invalid peer data received for leave:', peer);
        return;
      }
      
      const trimmedName = peer.displayName.trim();
      
      // Skip if it's ourselves
      if (trimmedName === effectiveDisplayName) {
        return;
      }
      
      const isAnonymous = trimmedName.startsWith('User_');
      const logMessage = isAnonymous 
        ? `üìù Anonymous user left: ${trimmedName}`
        : `üëã User left: ${trimmedName}`;
      
      console.log(logMessage, 'reason:', peer.reason);
      
      setConnectedPeers(prev => 
        prev.filter(name => name.trim() !== trimmedName)
      );
    });

  }, [roomId, effectiveDisplayName, connectionCooldown, retryCount, startHealthMonitoring, stopHealthMonitoring]);

  // Enhanced initialization effect
  useEffect(() => {
    if (roomId) {
      const persistedMessages = MessagePersistence.getRoomMessages(roomId);
      if (persistedMessages.length > 0) {
        console.log(`üìÇ Enhanced: Loaded ${persistedMessages.length} persisted messages for room ${roomId}`);
        setMessages(persistedMessages);
      }
    }
    
    // CRITICAL FIX: Only attempt ONE connection with strict guards
    if (roomId && effectiveDisplayName && 
        !isConnectingRef.current && 
        !connectionLockRef.current &&
        !(socketRef.current?.connected && roomConnectionRef.current === roomId)) {
      
      console.log(`üöÄ [${connectionId.current}] Enhanced initialization for:`, effectiveDisplayName);
      
      // CRITICAL FIX: Much longer delay and single attempt only
      setTimeout(async () => {
        // Double-check all conditions before attempting
        if (!effectiveDisplayName || 
            socketRef.current?.connected || 
            connectionLockRef.current ||
            isConnectingRef.current) {
          console.log(`‚è∏Ô∏è Initialization conditions changed, skipping connection`);
          return;
        }
        
        try {
          const serverUrl = getWebSocketServerUrl();
          const healthUrl = serverUrl.replace('ws://', 'http://').replace('wss://', 'https://') + '/health';
          
          console.log(`üè• Checking server health at: ${healthUrl}`);
          const response = await fetch(healthUrl, { 
            method: 'GET', 
            cache: 'no-cache',
            signal: AbortSignal.timeout(5000) // 5 second timeout
          });
          
          if (response.ok) {
            console.log(`‚úÖ Server health check passed, attempting single connection...`);
            connectToServer();
          } else {
            console.warn(`‚ö†Ô∏è Server health check failed:`, response.status);
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è Server health check error:`, error);
          console.log(`üõë NOT attempting connection due to health check failure`);
        }
      }, 5000); // Much longer 5 second delay
    }

    return () => {
      console.log(`üßπ [${connectionId.current}] Cleanup - releasing all locks`);
      
      setShouldAutoReconnect(false);
      stopHealthMonitoring();
      
      // CRITICAL FIX: Always release connection lock on cleanup
      connectionLockRef.current = false;
      
      if (autoReconnectTimer.current) {
        clearTimeout(autoReconnectTimer.current);
        autoReconnectTimer.current = null;
      }
      
      if (socketRef.current) {
        console.log(`üõë [${connectionId.current}] Enhanced cleanup - disconnecting`);
        const socket = socketRef.current;
        socketRef.current = null;
        isConnectingRef.current = false;
        roomConnectionRef.current = '';
        
        if (socket.connected || socket.disconnected === false) {
          socket.disconnect();
        }
      }
    };
  }, [roomId, effectiveDisplayName, connectToServer, stopHealthMonitoring]);

  // Enhanced send message function
  const sendMessage = useCallback((messageData: Omit<Message, 'id' | 'timestamp'>) => {
    const socket = socketRef.current;
    if (!socket || !socket.connected) {
      console.log('‚ùå Enhanced: Cannot send message - not connected');
      return generateCompatibleUUID();
    }

    if (!effectiveDisplayName) {
      console.log('‚ùå Enhanced: Cannot send message - no valid display name');
      return generateCompatibleUUID();
    }

    const messageId = generateCompatibleUUID();
    
    const messagePayload = {
      roomId,
      message: {
        content: messageData.content,
        id: messageId
      }
    };
    
    console.log('üì§ Enhanced: Sending message:', messageData.content);
    socket.emit('chat-message', messagePayload);
    
    return messageId;
  }, [roomId, effectiveDisplayName]);

  // Enhanced message handler registration
  const onMessage = useCallback((handler: (message: Message) => void) => {
    messageHandlersRef.current.add(handler);
    return () => {
      messageHandlersRef.current.delete(handler);
    };
  }, []);

  // Enhanced force reconnect with Cloud Run reset
  const forceReconnect = useCallback(async () => {
    console.log('üîÑ Enhanced Cloud Run force reconnect with full reset...');
    
    if (autoReconnectTimer.current) {
      clearTimeout(autoReconnectTimer.current);
      autoReconnectTimer.current = null;
    }
    
    stopHealthMonitoring();
    
    // Full reset of enhanced circuit breaker
    EnhancedConnectionResilience.reset();
    
    // Reset all local state
    setRetryCount(0);
    setConnectionCooldown(false);
    setShouldAutoReconnect(true);
    setConnectionQuality('unknown');
    
    // Clean disconnect
    if (socketRef.current) {
      socketRef.current.disconnect();
      socketRef.current = null;
    }
    
    isConnectingRef.current = false;
    roomConnectionRef.current = '';
    lastSuccessfulConnection.current = 0;
    
    // Attempt fresh connection with small delay for Cloud Run
    setTimeout(() => {
      connectToServer();
    }, 2000);
    
    return true;
  }, [connectToServer, stopHealthMonitoring]);
  
  // Enhanced connection diagnostics
  const getConnectionDiagnostics = useCallback(() => {
    return {
      enhancedCircuitBreaker: EnhancedConnectionResilience.getState(),
      healthMetrics: healthMonitor.current.getHealthMetrics(),
      connection: {
        isConnected,
        isRetrying,
        retryCount,
        connectionCooldown,
        connectionQuality,
        roomId: roomConnectionRef.current,
        peerId: myPeerId.current,
        lastSuccessfulConnection: lastSuccessfulConnection.current
      },
      socket: {
        exists: !!socketRef.current,
        connected: socketRef.current?.connected || false,
        id: socketRef.current?.id || null,
        transport: socketRef.current?.io.engine?.transport?.name || 'unknown'
      },
      timers: {
        autoReconnect: !!autoReconnectTimer.current,
        healthCheck: !!healthCheckTimer.current
      },
      cloudRun: {
        optimized: true,
        coldStartDetection: healthMonitor.current.getHealthMetrics().coldStartDetected
      }
    };
  }, [isConnected, isRetrying, retryCount, connectionCooldown, connectionQuality]);

  // Make debugging available globally
  if (typeof window !== 'undefined') {
    (window as any).EnhancedConnectionResilience = EnhancedConnectionResilience;
    (window as any).getConnectionDiagnostics = getConnectionDiagnostics;
  }

  return {
    peerId: myPeerId.current,
    status,
    isRetrying,
    retryCount,
    connectionQuality,
    messages,
    sendMessage,
    onMessage,
    forceReconnect,
    connectToPeer: async () => true,
    getConnectedPeers: () => connectedPeers,
    isSignalingConnected: isConnected,
    // Enhanced debugging and resilience features
    getConnectionDiagnostics,
    circuitBreakerState: EnhancedConnectionResilience.getState(),
    healthMetrics: healthMonitor.current.getHealthMetrics()
  };
}